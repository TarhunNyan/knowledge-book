
function walkAST( node, type ) {
    // console.log(node);
    if (node) {
        try {
            if( Array.isArray(node) ) {
                return type.ArrayParam( node );
            }
            return type[node.type]( node );
        } catch ( error ) {
            console.log('HERE');
            console.log( `ERROR: unexpect type "${node.type}". walkAST` );
            console.log(node);
            console.log(error);
        }
    }
};

let UpdateCode = {
    code: '',
    debug: function( node ) {
        if( this.isDebug ) {
            console.log(`!It is standart update behaviour of ` + node.type);
       }
    },

    replaceCode: function( node, str ) {
        let offset = str.length - ( node.end - node.start );
        this.code = this.code.slice(0, node.start).concat(str, this.code.slice(node.end));
        offset = this.updateLocation( node, offset );
        console.log( "Code\n" + this.code + "---\n" );
        return offset;
    },
    
    updateLength: function( node, length ) {
        node.end += length;
        return length;
    },

    updateOffset: function( node, offset) {
        node.offset = (node.offset ?? 0) + offset;
        node.start += offset;
        node.end += offset;
        return offset;
    },

    updateLocation: function( node, length, offset=0) {
        offset = this.updateOffset( node, offset );
        if( length > 0 ) { length = this.updateLength( node, length ) }
        return offset + length;
    },

    updateNodeLocation: function( node, params ) {
        // let preNode = { ...node };
        params = params.filter( param => node[param]!=null );

        let foo = 0;
        let sum = 0;
        for(let param of params) {
            let elem = node[param];
            this.updateOffset( elem, node.offset + sum );
            foo = walkAST(elem, this);
            sum += foo;
        }
        this.updateLength( node, sum );
        return sum;
    },
};

let UpdateNodes  = {
    __proto__: UpdateCode,

    ArrayParam: function( node ) {
        let params = [];
        for(let param=0; param<node.length; param++) {
            params.push( param );
        }
        return this.updateNodeLocation( node, params );
    },

    BlockStatement: function( node ) {
        // node.body[]
        return this.updateNodeLocation( node, ["body"] );
    },
    
    Program: function( node ) {
        // node.body[]
        node.offset = 0;
        node.body.map( (newNode) => { 
            this.updateOffset( newNode, node.offset );
            node.offset += walkAST(newNode, this) 
        } );
    },

    VariableDeclaration: function( node ) {
        // node.declarations[]
        return this.updateNodeLocation( node, ["declarations"] );
    },

    VariableDeclarator: function( node ) {
        // node.id, node.init
        return this.updateNodeLocation( node, ["id", "init"] );
    },

    BreakStatement: function( node ) {
        // node.label
        return this.updateNodeLocation( node, ["label"] );
    },

    ContinueStatement: function( node ) {
        // node.label
        return this.updateNodeLocation( node, ["label"] );
    },

    DebuggerStatement: function( node ) {
        return 0;
    },

    DoWhileStatement: function( node ) {
        // node.body, node.test
        return this.updateNodeLocation( node, ["body", "test"] );
    },

    IfStatement: function( node ) {
        // node.test, node.consequent, node.alternate
        return this.updateNodeLocation( node, ["test", "consequent", "alternate"] );
    },

    ReturnStatement: function( node ) {
        // node.argument
        return this.updateNodeLocation( node, ["argument"] );
    },

    SwitchCase: function( node ) {
        // node.consequent[], node.test
        return this.updateNodeLocation( node, ["consequent", "test"] );
    },

    SwitchStatement: function( node ) {
        // node.discriminant, node.cases[]
        return this.updateNodeLocation( node, ["discriminant", "cases"] );
    },

    ThrowStatement: function( node ) {
        // node.argument
        return this.updateNodeLocation( node, ["argument"] );
    },

    CatchClause: function( node ) {
        // node.param, node.body
        return this.updateNodeLocation( node, ["param", "body"] );
    },

    TryStatement: function( node ) {
        // node.block, node.handler, node.finalizer
        return this.updateNodeLocation( node, ["block", "handler", "finalizer"] );
    },

    WhileStatement: function( node ) {
        // node.test, node.body
        return this.updateNodeLocation( node, ["test", "body"] );
    },

    WithStatement: function( node ) {
        // node.object, node.body
        return this.updateNodeLocation( node, ["object", "body"] );
    },

    EmptyStatement: function( node ) {
        return 0;
    },

    LabeledStatement: function( node ) {
        // node.body, node.label
        return this.updateNodeLocation( node, ["label", "body"] );
        process.exit();
    },

    ForStatement: function( node ) {
        // node.init, node.test, node.update, node.body
        return this.updateNodeLocation( node, ["init", "test", "update", "body"] );
    },

    ForInStatement: function( node ) {
        // node.left, node.right, node.body
        return this.updateNodeLocation( node, ["left", "right", "body"] );
    },

    FunctionDeclaration: function( node ) {
        // node.id, node.params[], node.body
        return this.updateNodeLocation( node, ["id", "params", "body"] );
    },

    ClassBody: function( node ) {
        // node.body
        return this.updateNodeLocation( node, ["body"] );
    },

    ClassDeclaration: function( node ) {
        // node.id, node.superClass, node.body
        return this.updateNodeLocation( node, ["id", "superClass", "body"] );
    },

    ClassExpression: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    MethodDefinition: function( node ) {
        // node.static, node.computed, node.key, node.kind, node.value
        return this.updateNodeLocation( node, ["key", "value"] );
    },

    PropertyDefinition: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    StaticBlock: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    ExportAllDeclaration: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    ExportDefaultDeclaration: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    ExportNamedDeclaration: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    ExportSpecifier: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    ImportDeclaration: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    ImportDefaultSpecifier: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    ImportNamespaceSpecifier: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    ImportSpecifier: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    RestElement: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    ArrayPattern: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    AssignmentPattern: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    SequenceExpression: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    AssignmentExpression: function( node ) {
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    ConditionalExpression: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    LogicalExpression: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    UnaryExpression: function( node ) {
        console.log( node );
        // node.operator, node.prefix, node.argument
        return this.updateNodeLocation( node, ["argument"] );
    },

    UpdateExpression: function( node ) {
        // node.operator, node.argument
        return this.updateNodeLocation( node, ["argument"] );
    },

    ChainExpression: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    MemberExpression: function( node ) {
        // node.object, node.property, node.computed, node.optional
        return this.updateNodeLocation( node, ["object", "property"] );
    },

    CallExpression: function( node ) {
        // node.callee, node.arguments, node.optional
        return this.updateNodeLocation( node, ["callee", "arguments"] );
    },

    TaggedTemplateExpression: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    Super: function( node ) {
        return 0;
    },

    ThisExpression: function( node ) {
        return 0;
    },

    ArrayExpression: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    ImportExpression: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    Literal: function( node ) {
        // node.value, node.raw
        return 0;
        process.exit();
    },

    ParenthesizedExpression: function( node ) {
        console.log( node );
        process.exit();
    },

    MetaProperty: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    NewExpression: function( node ) {
        // node.callee, node.arguments[]
        return this.updateNodeLocation( node, ["callee", "arguments"] );
    },

    TemplateElement: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    TemplateLiteral: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    ObjectPattern: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    ObjectExpression: function( node ) {
        // node.properties
        return this.updateNodeLocation( node, ["properties"] );
    },

    SpreadElement: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    Property: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    FunctionExpression: function( node ) {
        // node.params[], node.body
        return this.updateNodeLocation( node, ["params", "body"] );
    },

    ArrowFunctionExpression: function( node ) {
        // node.params[], node.body
        return this.updateNodeLocation( node, ["params", "body"] );
    },

    PrivateIdentifier: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    YieldExpression: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    AwaitExpression: function( node ) {
        console.log( node );
        process.exit();
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    Identifier: function( node ) {
        // node.name
        return 0;
    },

    BinaryExpression: function( node ) {
        // node.left, node.right, node.operator
        return this.updateNodeLocation( node, ["left", "right"] );
    },

    ExpressionStatement: function( node ) {
        // node.expression
        return this.updateNodeLocation( node, ["expression"] );
    },
};

function compile( code, AST, updater=UpdateNodes ) {
    updater.code = code;
    walkAST( AST, updater );
    return updater.code;
};

module.exports = {
    compile,
    UpdateNodes,
    walkAST,
};

