<input type="checkbox" id="isClose"></input><div class="left-menu"><div class="control-panel"><label for="isClose"><div class="isClose"></div></label></div><div class="left-side-menu"><ul><a href="#object"><li>Object</li></a><ul><a href="#получить-ключизначения"><li>Получить ключи/значения</li></a><a href="#использовать-this-в-аттрибуте-функции"><li>Использовать this в аттрибуте функции</li></a><a href="#tostring-valueof"><li>toString, valueOf</li></a><a href="#instanceof"><li>instanceOf</li></a><a href="#typeof"><li>typeof</li></a><a href="#target"><li>target</li></a><a href="#иттерируемый-объект"><li>Иттерируемый объект</li></a></ul><a href="#уникальные-идентификаторыsymbol"><li>Уникальные идентификаторы(Symbol)</li></a><ul><a href="#основное-использование"><li>Основное использование</li></a><a href="#глобальный-реестр"><li>Глобальный реестр</li></a></ul><a href="#работа-со-свойстами"><li>Работа со свойстами</li></a><ul><a href="#defineproperty"><li>defineProperty</li></a><a href="#defineproperties"><li>defineProperties</li></a><a href="#getownpropertynames"><li>getOwnPropertyNames</li></a><a href="#getownpropertysymbols"><li>getOwnPropertySymbols</li></a><a href="#getownpropertydescriptor"><li>getOwnPropertyDescriptor</li></a><a href="#hasownproperty"><li>hasOwnProperty</li></a><a href="#запрет-на-добалениеудалениеизменение-объекта"><li>Запрет на добаление/удаление/изменение объекта</li></a><a href="#копировать-свойства"><li>Копировать свойства</li></a></ul><a href="#setter-и-getter"><li>Setter и getter</li></a><a href="#prototypes"><li>Prototypes</li></a><ul><a href="#является-ли-прототипом"><li>Является ли прототипом</li></a><a href="#пример"><li>Пример</li></a></ul><a href="#class"><li>Class</li></a><a href="#proxy"><li>Proxy</li></a><ul><a href="#get"><li>get</li></a><a href="#set"><li>set</li></a><a href="#ownkeys-objectkeys"><li>ownKeys (Object.keys)</li></a><a href="#getownpropertydescriptor-defineproperty"><li>getOwnPropertyDescriptor (defineProperty)</li></a><a href="#полный-список-значений-handler"><li>Полный список значений handler</li></a><a href="#revokeочистка"><li>revoke(очистка)</li></a></ul></ul></div></div><div class="main"><link rel="stylesheet" href="../../../static/style.css "><h1 id="object">Object</h1>
<h2 id="получить-ключизначения">Получить ключи/значения</h2>
<p>Возвращаеи массив со всеми свойстами(ключами), у которых <a href="#defineProperty">enumerable=true</a></p>
<pre><code class="hljs language-js"><span class="hljs-comment">// Получить свойства(ключи)</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>( obj );
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// Получить значения</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>( obj );
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// Получить ключи и значения</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj)) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${key}</span>: <span class="hljs-subst">${value}</span>`</span>);
}
</code></pre>
<h2 id="использовать-this-в-аттрибуте-функции">Использовать this в аттрибуте функции</h2>
<p>Важно чтобы функция была не стрелочной, тогда все работает</p>
<pre><code class="hljs language-js">obj = { 
    <span class="hljs-attr">val</span>: <span class="hljs-string">&quot;some val&quot;</span>,
    <span class="hljs-attr">run</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> }
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">run</span>);
</code></pre>
<h2 id="tostring-valueof">toString, valueOf</h2>
<p>Примитивы преобразуются так:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Что ожидает js</th>
<th style="text-align:left">=&gt;</th>
<th style="text-align:left">String</th>
<th style="text-align:left">Number</th>
<th style="text-align:left">Boolean</th>
<th style="text-align:left">null</th>
<th style="text-align:left">undefined</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Ожидает строку</td>
<td style="text-align:left">=&gt;</td>
<td style="text-align:left">-</td>
<td style="text-align:left">&quot;0&quot;</td>
<td style="text-align:left">&quot;true&quot;</td>
<td style="text-align:left">&quot;Null&quot;</td>
<td style="text-align:left">&quot;undefined&quot;</td>
</tr>
<tr>
<td style="text-align:left">Ожидает число</td>
<td style="text-align:left">=&gt;</td>
<td style="text-align:left">&quot;\t123\n&quot; =&gt; 123, &quot;text&quot; =&gt; NaN</td>
<td style="text-align:left">-</td>
<td style="text-align:left">true =&gt; 1, false =&gt; 0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">NaN</td>
</tr>
<tr>
<td style="text-align:left">Ожидает логическое значение</td>
<td style="text-align:left">=&gt;</td>
<td style="text-align:left">&quot;&quot; =&gt; false, остальное =&gt; true</td>
<td style="text-align:left">0 =&gt; false, остальное =&gt; true</td>
<td style="text-align:left">-</td>
<td style="text-align:left">false</td>
<td style="text-align:left">false</td>
</tr>
</tbody>
</table>
<p>Преобразование объекта в примитив вызывается автоматически многими встроенными функциями и операторами, которые ожидают примитив в качестве значения.</p>
<p>Существует всего 3 типа (хинта) для этого:</p>
<ul>
<li>&quot;string&quot; (для alert и других операций, которым нужна строка)</li>
<li>&quot;number&quot; (для математических операций)</li>
<li>&quot;default&quot; (для некоторых других операторов, обычно объекты реализуют его как &quot;number&quot;)
Спецификация явно описывает для каждого оператора, какой ему следует использовать хинт.</li>
</ul>
<p>Алгоритм преобразования таков:</p>
<ol>
<li>Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует,</li>
<li>В случае, если хинт равен &quot;string&quot;
<ul>
<li>происходит попытка вызвать obj.toString() или obj.valueOf(), смотря что есть.</li>
</ul>
</li>
<li>В случае, если хинт равен &quot;number&quot; или &quot;default&quot;
<ul>
<li>происходит попытка вызвать obj.valueOf() или obj.toString(), смотря что есть.</li>
</ul>
</li>
</ol>
<p>Все эти методы должны возвращать примитив (если определены)</p>
<h2 id="instanceof">instanceOf</h2>
<p>Проверить тип объекта</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj instanceOf <span class="hljs-title class_">String</span>)
<span class="hljs-comment">// =&gt; true или false</span>
</code></pre>
<h2 id="typeof">typeof</h2>
<p>Возвращает тип объекта</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> variable = <span class="hljs-number">10</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-keyword">typeof</span> variable);
<span class="hljs-comment">// =&gt; &quot;number&quot;</span>
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">Тип</th>
<th style="text-align:left">Результат typeof</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">undefined</td>
<td style="text-align:left">&quot;undefined&quot;</td>
</tr>
<tr>
<td style="text-align:left">Null</td>
<td style="text-align:left">&quot;object&quot;</td>
</tr>
<tr>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">&quot;boolean&quot;</td>
</tr>
<tr>
<td style="text-align:left">Number</td>
<td style="text-align:left">&quot;number&quot;</td>
</tr>
<tr>
<td style="text-align:left">String</td>
<td style="text-align:left">&quot;string&quot;</td>
</tr>
<tr>
<td style="text-align:left">Symbol</td>
<td style="text-align:left">&quot;symbol&quot;</td>
</tr>
<tr>
<td style="text-align:left">function</td>
<td style="text-align:left">&quot;function&quot;</td>
</tr>
<tr>
<td style="text-align:left">любой другой тип</td>
<td style="text-align:left">&quot;object&quot;</td>
</tr>
</tbody>
</table>
<h2 id="target">target</h2>
<p>Можно сделать обработку как функции так и как конструктора</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span>( !<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> ) { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot; Это функция &quot;</span>) }
    <span class="hljs-keyword">else</span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot; Это конструктор &quot;</span>) }
}

<span class="hljs-title class_">Constructor</span>();
<span class="hljs-comment">// =&gt; Это функция</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Constructor</span>();
<span class="hljs-comment">// =&gt; Это конструктор</span>
</code></pre>
<h2 id="иттерируемый-объект">Иттерируемый объект</h2>
<p>Кастомный иттерируемый объект</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> iterable = {
  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">i</span>: <span class="hljs-number">0</span>,
      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">i</span> &lt; <span class="hljs-number">3</span>) {
          <span class="hljs-keyword">return</span> { <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">i</span>++, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> };
        }
        <span class="hljs-keyword">return</span> { <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> };
      }
    };
  }
};

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> value <span class="hljs-keyword">of</span> iterable) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);
}
<span class="hljs-comment">// =&gt; 0, 1, 2</span>
</code></pre>
<h1 id="уникальные-идентификаторыsymbol">Уникальные идентификаторы(Symbol)</h1>
<h2 id="основное-использование">Основное использование</h2>
<p>Чтобы у объекто(например из библиотеки) не пересекались имена, используется примитив Symbol. Он создает уникальные идентификаторы, так еще и скрытый</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;Description here&quot;</span>);
<span class="hljs-keyword">let</span> name = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;name is here&quot;</span>);

<span class="hljs-keyword">let</span> obj = {
    [name]: <span class="hljs-string">&quot;Vasia&quot;</span>
}
obj[id] = <span class="hljs-number">20</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( id.<span class="hljs-property">description</span> );
<span class="hljs-comment">// =&gt; Description here</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj[id] );
<span class="hljs-comment">// =&gt; 20</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj) );
<span class="hljs-comment">// =&gt; []</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(obj) );
<span class="hljs-comment">// =&gt; []</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj) );
<span class="hljs-comment">// =&gt; [ Symbol(id) ]</span>
</code></pre>
<h2 id="глобальный-реестр">Глобальный реестр</h2>
<pre><code class="hljs language-js"><span class="hljs-comment">// Создаем Symbol в глобальном реестре</span>
<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;id&quot;</span>);
<span class="hljs-comment">// Считываем его</span>
<span class="hljs-keyword">let</span> id = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&quot;id description&quot;</span>);

<span class="hljs-comment">// Получаем description</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">keyFor</span>(id) );
<span class="hljs-comment">// =&gt; id description</span>
</code></pre>
<h1 id="работа-со-свойстами">Работа со свойстами</h1>
<h2 id="defineproperty">defineProperty</h2>
<p>Задает новый аттрибут, а третье свойство задает поведение аттрибута. В нем прописываются свойства типа такого:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> obj = { <span class="hljs-attr">prop</span>: <span class="hljs-string">&quot;value&quot;</span> }
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;prop2&quot;</span>, {
    <span class="hljs-comment">// значение аттрибута</span>
    <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;Value&quot;</span>,
    <span class="hljs-comment">// запретить присвоение типа obj.prop2=</span>
    <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-comment">// запретить удаление типа delete obj.prop2</span>
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>,

    <span class="hljs-comment">// спрятать свйоство от Object.keys или for ... in</span>
    <span class="hljs-comment">// но свойство спокойно вызывается</span>
    <span class="hljs-comment">// сокрытие как у встроенных функций</span>
    <span class="hljs-comment">// Object.getOwnPropertyNames вернет все свойства включая этот</span>
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,

    <span class="hljs-comment">// геттер и сеттер</span>
    <span class="hljs-comment">// с ними нельзя задавать одновременно value и writable</span>
    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">prop2</span>(<span class="hljs-params"></span>) { ... },
    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">prop2</span>(<span class="hljs-params"> value </span>) { ... },
});
</code></pre>
<h2 id="defineproperties">defineProperties</h2>
<p>Как <a href="#defineProperty">defineProperty</a>, только задается сразу несколько свойств</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>( obj, {
    <span class="hljs-attr">firstProp</span>: { 
        <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;Value&quot;</span>
    },
    <span class="hljs-attr">secondProp</span>: { ... },
    <span class="hljs-attr">thirdProp</span>: {
        <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { ... }
    }
});
</code></pre>
<h2 id="getownpropertynames">getOwnPropertyNames</h2>
<p>Работает как Object.keys, но возвращает все свойства, вне зависисмости от значения <a href="#defineProperty">enumerable</a></p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>( obj );
</code></pre>
<h2 id="getownpropertysymbols">getOwnPropertySymbols</h2>
<p>Работает как Object.keys, но возвращает только <a href="#%D1%83%D0%BD%D0%B8%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D1%8Bsymbol">симольные свойства</a></p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>( obj );
</code></pre>
<h2 id="getownpropertydescriptor">getOwnPropertyDescriptor</h2>
<p>Получаем descriptor атрибута. То бишь то, что в <a href="#defineProperty">defineProperty</a> задается третим параметром</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>( obj, <span class="hljs-string">&#x27;propName&#x27;</span>);
</code></pre>
<h2 id="hasownproperty">hasOwnProperty</h2>
<p>Возвращает логическое значение, указывающее, содержит ли объект указанное свойство как прямое свойство этого объекта, а не унаследованное через цепочку прототипов</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> obj = { <span class="hljs-attr">a</span>:<span class="hljs-number">100</span> };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;a&quot;</span>) );
<span class="hljs-comment">// =&gt; true</span>
</code></pre>
<h2 id="запрет-на-добалениеудалениеизменение-объекта">Запрет на добаление/удаление/изменение объекта</h2>
<p>Запрещает добавление свойств в объект</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtnsions</span>(obj);
<span class="hljs-comment">// проверяет запрет</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isExtensible</span>(obj);
</code></pre>
<p>Запрещает добавление и удаление свойств</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>(obj);
<span class="hljs-comment">// проверяет запрет</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isSealed</span>(obj);
</code></pre>
<p>Запрещает добаление, удаление и изменение свойств</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(obj);
<span class="hljs-comment">// проверяет запрет</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isFrozen</span>(obj);
</code></pre>
<h2 id="копировать-свойства">Копировать свойства</h2>
<p>Копирует все <a href="#defineProperty">enumerable</a> свойства из объектов в объект</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj1 = { <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">c</span>:<span class="hljs-number">1</span> };
<span class="hljs-keyword">const</span> obj2 = { <span class="hljs-attr">d</span>:<span class="hljs-number">2</span>, <span class="hljs-attr">e</span>: { <span class="hljs-attr">c</span>: <span class="hljs-number">0</span> }};

<span class="hljs-comment">// Копируем свойства из obj1 и obj2 в новый объект</span>
<span class="hljs-comment">// Результат записываем в obj3</span>
<span class="hljs-comment">// Копиия не глубокая и obj3.e.c содержит ссылку</span>
<span class="hljs-keyword">const</span> obj3 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, obj1, obj2);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj3 );
<span class="hljs-comment">// =&gt; { a:1, b:1, c:1, d:2, e: { c:0 }}</span>
</code></pre>
<p>Коипрование через Spread(оператор расширения)</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj1 = { <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">c</span>:<span class="hljs-number">1</span> };
<span class="hljs-keyword">const</span> obj2 = { <span class="hljs-attr">d</span>:<span class="hljs-number">2</span>, <span class="hljs-attr">e</span>: { <span class="hljs-attr">c</span>: <span class="hljs-number">0</span> }};

<span class="hljs-comment">// Копируем свойства из obj1 и obj2 в новый объект</span>
<span class="hljs-comment">// Результат записываем в obj3</span>
<span class="hljs-comment">// Копиия не глубокая и obj3.e.c содержит ссылку</span>
<span class="hljs-keyword">const</span> obj3 = { ...obj1, ...boj2 };

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj3 );
<span class="hljs-comment">// =&gt; { a:1, b:1, c:1, d:2, e: { c:0 }}</span>
</code></pre>
<h1 id="setter-и-getter">Setter и getter</h1>
<p>Смотри <a href="#define-property">defineProperty</a><br>
Смотри второй пример в <a href="#class">Class</a></p>
<p>Или вот так:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> user = {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;Вася&quot;</span>,
    <span class="hljs-attr">surname</span>: <span class="hljs-string">&quot;Петров&quot;</span>,

    <span class="hljs-keyword">get</span> <span class="hljs-title function_">fullName</span>() {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">surname</span>;
    },

    <span class="hljs-keyword">set</span> <span class="hljs-title function_">fullName</span>(<span class="hljs-params">value</span>) {
      <span class="hljs-keyword">var</span> split = value.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = split[<span class="hljs-number">0</span>];
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">surname</span> = split[<span class="hljs-number">1</span>];
    }
};
</code></pre>
<h1 id="prototypes">Prototypes</h1>
<p>Все не очень сложно, хоть и немного запутано. Итак, у каждого объекта(кроме undefine) есть свойство <strong><code>__proto__</code></strong>:</p>
<ul>
<li>Что такое <strong><code>__proto__</code></strong>?
<ul>
<li>Ссылка на объект</li>
</ul>
</li>
<li>Откуда берется <strong><code>__proto__</code></strong>?
<ul>
<li>Копируется из аттрибута <strong>prototype</strong> функции конструктора</li>
</ul>
</li>
<li>Зачем нужен <strong><code>__proto__</code></strong>?
<ul>
<li>Если у объекта нет аттрибута, он берется у объекта из <strong><code>__proto__</code></strong>. А поскольку <strong><code>__proto__</code></strong> это объект, к нему это правило так же применяется. И идет дальше по всей цепочке</li>
</ul>
</li>
</ul>
<h2 id="является-ли-прототипом">Является ли прототипом</h2>
<p>Проверяем, у checkObj в цепочке прототипов присутствует obj.prototype?</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
    obj.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>( checkObj )
);
<span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>Проверяем, у checkObj в цепочке прототипов присутствует obj.prototype?</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(checkObj instanceOf obj.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-comment">// =&gt; true</span>
</code></pre>
<h2 id="пример">Пример</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">constructorFunc</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">someVariable</span> = <span class="hljs-string">&quot;value&quot;</span>
}
constructorFunc.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = { <span class="hljs-attr">ok</span>: <span class="hljs-number">200</span> }

<span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title function_">constructorFunc</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj.<span class="hljs-property">someVariable</span> )
<span class="hljs-comment">// =&gt; &quot;value&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj.<span class="hljs-property">ok</span> )
<span class="hljs-comment">// =&gt; 200</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj.<span class="hljs-property">__proto__</span> )
<span class="hljs-comment">// =&gt; { ok: 200 }</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj.<span class="hljs-property">__proto__</span> === constructorFunc.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> )
<span class="hljs-comment">// =&gt; true</span>
</code></pre>
<p>Изменив <strong>prototype</strong> старые объекты не изменятся, а новые объекты будут ссылаться на другой объект</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">constructorFunc</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">someVariable</span> = <span class="hljs-string">&quot;value&quot;</span>
}
constructorFunc.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = { <span class="hljs-attr">ok</span>: <span class="hljs-number">200</span> }

<span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title function_">constructorFunc</span>();

constructorFunc.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = { <span class="hljs-attr">ok</span>: <span class="hljs-number">400</span> }
<span class="hljs-keyword">const</span> newObj = <span class="hljs-keyword">new</span> <span class="hljs-title function_">constructorFunc</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj.<span class="hljs-property">ok</span> )
<span class="hljs-comment">// =&gt; 200</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( newObj.<span class="hljs-property">ok</span> )
<span class="hljs-comment">// =&gt; 400</span>
</code></pre>
<p>Изменив <strong><code>__proto__</code></strong> старые объект изменятся, а новые объекты нет</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">constructorFunc</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">someVariable</span> = <span class="hljs-string">&quot;value&quot;</span>
}
constructorFunc.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = { <span class="hljs-attr">ok</span>: <span class="hljs-number">200</span> }

<span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title function_">constructorFunc</span>();
obj.<span class="hljs-property">__proto__</span> = { <span class="hljs-attr">ok</span>: <span class="hljs-number">400</span> }

<span class="hljs-keyword">const</span> newObj = <span class="hljs-keyword">new</span> <span class="hljs-title function_">constructorFunc</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj.<span class="hljs-property">ok</span> )
<span class="hljs-comment">// =&gt; 400</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( newObj.<span class="hljs-property">ok</span> )
<span class="hljs-comment">// =&gt; 200</span>
</code></pre>
<h1 id="class">Class</h1>
<p>Чисто синтаксический сахар, но знать надо</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {

    <span class="hljs-comment">// список свойств для упрощения чтения кода</span>
    name;

    <span class="hljs-comment">// конструктор вызываемый new</span>
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Lena</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> {
    
    <span class="hljs-comment">// приватная переменная. Доступно только внутри класса</span>
    #year;
    
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// super вызывает конструктор предка применительно к текущему объекту</span>
        <span class="hljs-variable language_">super</span>(<span class="hljs-string">&#x27;Lena&#x27;</span>)
        <span class="hljs-variable language_">this</span>.#year = <span class="hljs-number">1990</span>;
    }
    
    <span class="hljs-comment">// приватная функция. Доступно только внутри класса</span>
    #<span class="hljs-title function_">somePrivateMethod</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;You called me?&#x27;</span>);
    }

    <span class="hljs-comment">// getter и stter</span>
    <span class="hljs-keyword">get</span> <span class="hljs-title function_">firstName</span>() { ... }
    <span class="hljs-keyword">set</span> <span class="hljs-title function_">firstName</span>(<span class="hljs-params"> value </span>) { ... }

    <span class="hljs-comment">// static block - срабатывает один раз, как обычный код </span>
    <span class="hljs-keyword">static</span> {
        coonsole.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;ok&quot;</span>);
    }
}

<span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Vova&#x27;</span>);
<span class="hljs-keyword">let</span> lena = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Lena</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( person.<span class="hljs-property">name</span> )
<span class="hljs-comment">// =&gt; Vova</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( lena.<span class="hljs-property">name</span> )
<span class="hljs-comment">// =&gt; Lena</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( lena.<span class="hljs-property">year</span> )
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( lena.#year )
<span class="hljs-comment">// =&gt; ERROR</span>
</code></pre>
<h1 id="proxy">Proxy</h1>
<p>Очень крутая штука. Но появилась недавно. На MDN написано, что node.js поддерживает Proxy начиная с версии 6, а она вышла в 2019 году, так что уже наверное не новая</p>
<p>Позволяет перехатывать вызовы свойств объектов, и обрабатывать даже не существующие вызовы. Дико пригодилось в создании <a href="">конвертера физических величин</a></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> target = { ... };
target = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>( target, handler );
</code></pre>
<p>В handler настраиваем что перехатыать, а что нет</p>
<h2 id="get">get</h2>
<p>set и get обладают особенностью, которая срабатывает на setter и getter. Дополнительное свойство reieve</p>
<p>Пример с перехватом всех свойств:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

<span class="hljs-comment">// если элемента нет, то вернет 0</span>
numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>( numbers, {
    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop</span>) {
        <span class="hljs-keyword">if</span>(prop <span class="hljs-keyword">in</span> target) { <span class="hljs-keyword">return</span> target[prop]; }
        <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }
    },
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( numbers[<span class="hljs-number">1</span>] );
<span class="hljs-comment">// =&gt; 2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( numbers[<span class="hljs-number">123124122</span>] );
<span class="hljs-comment">// =&gt; 0</span>
</code></pre>
<h2 id="set">set</h2>
<p>set и get обладают особенностью, которая срабатывает на setter и getter. Дополнительное свойство reieve</p>
<p>Пример перехвата всех записей (возвращать true/false - обязательно)</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> numbers = [];

<span class="hljs-comment">// теперь numbers принимает только числа</span>
numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(numbers, {
    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, prop, value</span>) {
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;number&quot;</span>) {
            target[prop] = value;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; }
    },
});
</code></pre>
<h2 id="ownkeys-objectkeys">ownKeys (Object.keys)</h2>
<p>Вернет те записи, которые в return (Object.keys проверяет флаг enumerable, поэтому несуществущих свойст не врнет. Смотри <a href="#getOwnPropertyDescriptor-defineProperty">getOwnPropertyDescriptor</a></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> user = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Vasia&quot;</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,
    <span class="hljs-attr">_password</span>: <span class="hljs-string">&quot;*****&quot;</span>,
};

<span class="hljs-comment">// вернет все свойства начинающиеся не с _</span>
user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(user, {
    <span class="hljs-title function_">ownKeys</span>(<span class="hljs-params">target</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(target).<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> {
            <span class="hljs-keyword">return</span> !key.<span class="hljs-title function_">strtsWith</span>(<span class="hljs-string">&#x27;_&#x27;</span>);
        });
    },
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(user) );
<span class="hljs-comment">// =&gt; [&quot;name, &quot;age&quot;]</span>
</code></pre>
<h2 id="getownpropertydescriptor-defineproperty">getOwnPropertyDescriptor (defineProperty)</h2>
<p>Подсунет другой дескриптор</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> user = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Vasia&quot;</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,
    <span class="hljs-attr">_password</span>: <span class="hljs-string">&quot;*****&quot;</span>,
};

<span class="hljs-comment">// Только a, b и c</span>
user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(user, {
    <span class="hljs-title function_">ownKeys</span>(<span class="hljs-params">target</span>) {
        <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];
    },

    <span class="hljs-title function_">getOwnPropertyDescriptor</span>(<span class="hljs-params">target, pop</span>) {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>
        }
    }
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(user) );
<span class="hljs-comment">// =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
</code></pre>
<h2 id="полный-список-значений-handler">Полный список значений handler</h2>
<table>
<thead>
<tr>
<th style="text-align:left">Значение</th>
<th style="text-align:left">Внутренний метод</th>
<th style="text-align:left">Что вызывает</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">get</td>
<td style="text-align:left">[[Get]]</td>
<td style="text-align:left">Чтение свойства</td>
</tr>
<tr>
<td style="text-align:left">set</td>
<td style="text-align:left">[[Set]]</td>
<td style="text-align:left">Запись свойства</td>
</tr>
<tr>
<td style="text-align:left">has</td>
<td style="text-align:left">[[HasProperty]]</td>
<td style="text-align:left">Оператор in</td>
</tr>
<tr>
<td style="text-align:left">deleteProperty</td>
<td style="text-align:left">[[Delete]]</td>
<td style="text-align:left">Оператор delete</td>
</tr>
<tr>
<td style="text-align:left">apply</td>
<td style="text-align:left">[[Call]]</td>
<td style="text-align:left">Вызов функции</td>
</tr>
<tr>
<td style="text-align:left">construct</td>
<td style="text-align:left">[[Construct]]</td>
<td style="text-align:left">Оператор new</td>
</tr>
<tr>
<td style="text-align:left">getPrototypeOf</td>
<td style="text-align:left">[[GetPrototypeOf]]</td>
<td style="text-align:left">Object.getPrototypeOf</td>
</tr>
<tr>
<td style="text-align:left">setPrototypeOf</td>
<td style="text-align:left">[[SetPrototypeOf]]</td>
<td style="text-align:left">Object.setPrototypeOf</td>
</tr>
<tr>
<td style="text-align:left">isExtensible</td>
<td style="text-align:left">[[IsExtensible]]</td>
<td style="text-align:left">Object.isExtensible</td>
</tr>
<tr>
<td style="text-align:left">preventExtensions</td>
<td style="text-align:left">[[PreventExtensions]]</td>
<td style="text-align:left">Object.preventExtensions</td>
</tr>
<tr>
<td style="text-align:left">defineProperty</td>
<td style="text-align:left">[[DefineProperty]]</td>
<td style="text-align:left">Object.defineProperty, Object.defineProperties</td>
</tr>
<tr>
<td style="text-align:left">getOwnProperty</td>
<td style="text-align:left">[[GetOwnProperty]]</td>
<td style="text-align:left">Object.getOwnPropertyDescriptor, for ... in, Object.keys/values/entries</td>
</tr>
<tr>
<td style="text-align:left">ownKeys</td>
<td style="text-align:left">[[OwnPropertyKeys]]</td>
<td style="text-align:left">Object.getOwnPropertyNames, Object.getOwnPropertySymbols, for ... in, Object.keys/values/entries</td>
</tr>
</tbody>
</table>
<h2 id="revokeочистка">revoke(очистка)</h2>
<p>Дело в том, что сборщик муосра не может удалить объект, поскольку есть на него ссылка в Proxy. Функция revoke, отвязывает объект от прокси и сборщик его удалит. В примере используется weakMap, ссылки хранящиеся в нем - игнорируются сборщиком мусора</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> revokes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();

<span class="hljs-keyword">let</span> object = {
  <span class="hljs-attr">data</span>: <span class="hljs-string">&quot;Важные данные&quot;</span>
};

<span class="hljs-keyword">let</span> {proxy, revoke} = <span class="hljs-title class_">Proxy</span>.<span class="hljs-title function_">revocable</span>(object, {});

revokes.<span class="hljs-title function_">set</span>(proxy, revoke);

<span class="hljs-comment">// ..позже в коде..</span>
revoke = revokes.<span class="hljs-title function_">get</span>(proxy);
<span class="hljs-title function_">revoke</span>();

<span class="hljs-title function_">alert</span>(proxy.<span class="hljs-property">data</span>); <span class="hljs-comment">// Ошибка (прокси отключён</span>
</code></pre>
</div>