# SQL

В этой статье приведен базовый синтаксис SQL. В разных софтах разная его реализация

# SELECT 

Классический CASE 

## EXISTS

Предикат EXISTS принимает значение TRUE, если подзапрос возвращает любое количество строк, иначе его значение равно FALSE. Для NOT EXISTS все наоборот. Этот предикат никогда не принимает значение UNKNOWN

````sql
[NOT] EXISTS (<табличный подзапрос>)
````

## GROUP BY

Создает в таблие группы, по значениям из выбранного столбца

````sql
SELECT model, COUNT(model) AS Qty_model, AVG(price) AS Avg_price FROM PC
GROUP BY model;
````

## HAVING

HAVING - как WHERE, но проверка делается для каждой группы полученной GROUP BY отдельно

Так же не стоит забывать порядок обработки селект запроса, из-за чего псевдонимы с использованием агрегатных функций тупо не работают:

````sql
SELECT model, COUNT(model) AS Qty_model, AVG(price) AS Avg_price
FROM PC
GROUP BY model
HAVING AVG(price) < 800;
````

## UNION, INTERSECT и EXCEPT

lt;запрос 1&gt;
<b>UNION</b> [ALL]
&lt;запрос 2&gt;

Оператор UNION объединяет выходные строки каждого из запросов в один результирующий набор. Если определен параметр ALL, то сохраняются все дубликаты выходных строк

При этом должны выполняться следующие условия:
1. Количество выходных столбцов каждого из запросов должно быть одинаковым.
2. Выходные столбцы каждого из запросов должны быть сравнимыми между собой (в порядке их следования) по типам данных.
3. В результирующем наборе используются имена столбцов, заданные в первом запросе.
4. Предложение ORDER BY применяется к результату соединения, поэтому оно может быть указано только в конце составного запроса

<b>INTERSECT</b>(пересечение) и <b>EXCEPT</b>(разность) - работают аналогично предложению UNION. Есть далеко не во всех СУБД

## JOIN

Соеднинение таблиц с предикатом:

SELECT maker, Product.model AS model_1, PC.model AS model_2, price
FROM Product
<b>INNER JOIN</b> PC ON PC.model = Product.model

Где:
1. INNER - значение есть в обеих таблицах
2. LEFT - из 1 табл(в примере Product) берут ВСЕ значения, а из 2 таблицы могут и NULL добавить
3. RIGHT&nbsp;- из 2 табл(в примере&nbsp;PC)&nbsp;берут ВСЕ значения, а из 1 таблицы могут и NULL добавить
4. FULL - из 1 и 2 табл берут ВСЕ значения

## SOME, ANY, ALL

lt;выражение&gt; &lt;оператор сравнения&gt; <b>SOME|ANY|ALL</b> (&lt;подзапрос&gt;)


(&lt;подзапрос&gt;) - один столбец величин

<b>SOME</b> и <b>ANY</b> это одно и тоже. Для каждой ячейки (&lt;подзапрос&gt;) производится сравнение с выражением. Если хоть одно сравнение TRUE, то вернётся TRUE

<b>ALL</b> для каждой ячейки (&lt;подзапрос&gt;) производится сравнение с выражением. Если все сравнения возвращают TRUE, то вернётся ALL тоже верно TRUE

## CASE

````sql
CASE <проверяемое выражение>
   WHEN <сравниваемое выражение 1>
   THEN <возвращаемое значение 1>
   …
   WHEN <сравниваемое выражение N>
   THEN <возвращаемое значение N>
[ELSE <возвращаемое значение>]
END
````

2-я форма этого выражения

````sql
CASE
   WHEN <предикат 1>
   THEN <возвращаемое значение 1>
   …
   WHEN <предикат N>
   THEN <возвращаемое значение N>
[ELSE <возвращаемое значение>]
END
````

# Рецепты

## Вытащить столбцы(в произвольном порядке)

````sql
SELECT * FROM Pc;
````

## Вытащить столбцы(упорядоченно)

````sql
SELECT speed, ram FROM Pc;
````

## Вытащить столбцы(с уникальными строками)

````sql
SELECT DISTINCT speed, ram FROM Pc;
````

## Получить строки с пустыми значениями

````sql 
SELECT * FROM Pc WHERE price IS NULL;
````

## Подзапрос внутри FROM 

````sql 
SELECT DISTINCT PC.model, maker
FROM PC, (SELECT maker, model FROM Product) AS prod
WHERE PC.model = prod.model AND price > 600;
````

## Переименовать столбцы 

````sql
SELECT ram AS Mb, hd Gb FROM ... WHERE ...;
````

## Горизонтальная выборка

````sql
 SELECT DISTINCT speed, ram 
FROM Pc
WHERE price<500
ORDER BY 2 DESC;
````

Так же можно производить математические операции со значениями столбцов: 

````sql
...
ram - 128 > 0
...
````

````sql
...
price <= speed*2 
...
````

## Агрегатные функции

| Название функции  | Что делает                                          |
|:------------------|:----------------------------------------------------|
| COUNT(\*)       	| Возвращает количество строк источника записей       |
| COUNT(<имя поля>) | Возвращает количество значений в указанном столбце  |
| SUM(<имя поля>)   | Возвращает сумму значений в указанном столбце       |
| AVG(<имя поля>)   | Возвращает среднее значение в указанном столбце     |
| MIN(<имя поля>)   | Возвращает минимальное значение в указанном столбце |
| MAX(<имя поля>)   | Возвращает максимальное значение в указанном столбц |

Пример:

````sql
SELECT MIN(price) AS Min_price, MAX(price) AS Max_price FROM PC;
````
