# SQL

В этой статье приведен базовый синтаксис SQL. В разных софтах разная его реализация

# SELECT 

Классический CASE 

## EXISTS

Предикат EXISTS принимает значение TRUE, если подзапрос возвращает любое количество строк, иначе его значение равно FALSE. Для NOT EXISTS все наоборот. Этот предикат никогда не принимает значение UNKNOWN

````sql
[NOT] EXISTS (<табличный подзапрос>)
````

## GROUP BY

Создает в таблие группы, по значениям из выбранного столбца

````sql
SELECT model, COUNT(model) AS Qty_model, AVG(price) AS Avg_price FROM PC
GROUP BY model;
````

## HAVING

HAVING - как WHERE, но проверка делается для каждой группы полученной GROUP BY отдельно

Так же не стоит забывать порядок обработки селект запроса, из-за чего псевдонимы с использованием агрегатных функций тупо не работают:

````sql
SELECT model, COUNT(model) AS Qty_model, AVG(price) AS Avg_price
FROM PC
GROUP BY model
HAVING AVG(price) < 800;
````

## UNION, INTERSECT и EXCEPT

lt;запрос 1&gt;
<b>UNION</b> [ALL]
&lt;запрос 2&gt;

Оператор UNION объединяет выходные строки каждого из запросов в один результирующий набор. Если определен параметр ALL, то сохраняются все дубликаты выходных строк

При этом должны выполняться следующие условия:
1. Количество выходных столбцов каждого из запросов должно быть одинаковым.
2. Выходные столбцы каждого из запросов должны быть сравнимыми между собой (в порядке их следования) по типам данных.
3. В результирующем наборе используются имена столбцов, заданные в первом запросе.
4. Предложение ORDER BY применяется к результату соединения, поэтому оно может быть указано только в конце составного запроса

<b>INTERSECT</b>(пересечение) и <b>EXCEPT</b>(разность) - работают аналогично предложению UNION. Есть далеко не во всех СУБД

## JOIN

Соеднинение таблиц с предикатом:

SELECT maker, Product.model AS model_1, PC.model AS model_2, price
FROM Product
<b>INNER JOIN</b> PC ON PC.model = Product.model

Где:
1. INNER - значение есть в обеих таблицах
2. LEFT - из 1 табл(в примере Product) берут ВСЕ значения, а из 2 таблицы могут и NULL добавить
3. RIGHT&nbsp;- из 2 табл(в примере&nbsp;PC)&nbsp;берут ВСЕ значения, а из 1 таблицы могут и NULL добавить
4. FULL - из 1 и 2 табл берут ВСЕ значения

## SOME, ANY, ALL

lt;выражение&gt; &lt;оператор сравнения&gt; <b>SOME|ANY|ALL</b> (&lt;подзапрос&gt;)


(&lt;подзапрос&gt;) - один столбец величин

<b>SOME</b> и <b>ANY</b> это одно и тоже. Для каждой ячейки (&lt;подзапрос&gt;) производится сравнение с выражением. Если хоть одно сравнение TRUE, то вернётся TRUE

<b>ALL</b> для каждой ячейки (&lt;подзапрос&gt;) производится сравнение с выражением. Если все сравнения возвращают TRUE, то вернётся ALL тоже верно TRUE

## CASE

````sql
CASE <проверяемое выражение>
   WHEN <сравниваемое выражение 1>
   THEN <возвращаемое значение 1>
   …
   WHEN <сравниваемое выражение N>
   THEN <возвращаемое значение N>
[ELSE <возвращаемое значение>]
END
````

2-я форма этого выражения

````sql
CASE
   WHEN <предикат 1>
   THEN <возвращаемое значение 1>
   …
   WHEN <предикат N>
   THEN <возвращаемое значение N>
[ELSE <возвращаемое значение>]
END
````
